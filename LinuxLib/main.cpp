/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// MultiThread
/// C++ Run Time Library Multithreading
///
/// Windowsのマルチスレッドには4種類あります
/// 使い分けが必要ですが、結局、Win32が一番使い勝手が良い
/// 
/// ①C++11のライブラリ
/// ②C Run Time Library
/// ③MFC Multithread
/// ④Win32 API Multithread
/// ⑤Linux Multithread   <----- これ！
/// 
///     2021/09/06      Retar.jp 
///
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <algorithm>
#include <pthread.h>
#include <vector>
#include <thread>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// スレッド関数・pthread
void* ThreadProc(void* p);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main()
{
	//数字列
	std::vector<double> closePrice = { 10.0f,20.0f,30.0f };
	std::for_each(closePrice.begin(), closePrice.end(), [](double& cPrice) {std::cout << cPrice << " " << std::endl; });

	//スレッドを生成してエラーにならないチェック
	try {
		//スレッドオブジェクト
		pthread_t hthread;
		//スレッドを生成
		pthread_create(&hthread , 0, ThreadProc, &closePrice);
		//スレッドを実行
		pthread_join(hthread, NULL);
	}
	catch (std::exception& ex) {
		std::cerr << ex.what() << std::endl;
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	printf("\r\nDone....");
	auto chAnswer = getchar();
	return 0;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// スレッド関数
void* ThreadProc(void* p)
{
	std::vector<double> closePrice = *((std::vector<double>*)p);
	//演算
	double sum = 0.0f;
	for (auto itr = closePrice.begin(); itr != closePrice.end(); itr++)
	{
		sum += (*itr);
	}
	std::cout << "sum : " << sum << "  average : " << sum / closePrice.size() << std::endl;

	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
