/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///
/// MultiThread
/// C++ Run Time Library Multithreading
///
/// Windowsのマルチスレッドには4種類あります
/// 使い分けが必要ですが、結局、Win32が一番使い勝手が良い
/// 
/// ①C++11のライブラリ
/// ②C Run Time Library
/// ③MFC Multithread     <----- これ！
/// ④Win32 API Multithread 
/// ⑤Linux Multithread
/// 
///     2021/09/06      Retar.jp 
/// 
/// MFCで定義されているスレッド・データ
/// 
/// AfxBeginThread
/// 
/// Win32のラッパーっぽいのでWin32の方が良いのでは
/// MFCはWin32との相性が悪いので注意を！
/// 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#include <windows.h>			//MFCとWin32は相性が悪い！！！
#include <afxres.h>
#include <afxwin.h>
#include <iostream>
#include <algorithm>
#include <vector>
#define _AFXDLL
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////スレッドに渡す引数
struct lpVOID
{
	std::vector<double> closePrice;
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// スレッド関数
UINT ThreadProc(LPVOID param);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//WinMain
int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_  HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nShowCmd)
{
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//コンソールがないときは割り当てる
	if (!AttachConsole(ATTACH_PARENT_PROCESS)) {
		if (AllocConsole() == FALSE)
		{
			std::cout << "Console Error : " << GetLastError() << std::endl;
			return 1;
		}
	}
	//入出力先を変更
	FILE* fpOut = NULL;
	::freopen_s(&fpOut, "CONOUT$", "w", stdout);
	FILE* fpErr = NULL;
	::freopen_s(&fpErr, "CONOUT$", "w", stderr);
	FILE* fpIn = NULL;
	::freopen_s(&fpIn, "CONIN$", "r", stdin);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//数字列
	std::vector<double> closePrice = { 10.0f,20.0f,30.0f };
	std::for_each(closePrice.begin(), closePrice.end(), [](auto& cPrice) {std::cout << cPrice << " " << std::endl; });

	//スレッドのハンドラ
	//HANDLE handle;
	lpVOID tobj;
	tobj.closePrice = closePrice;

	//MFCのスレッド呼び出し
	auto m_pThread = AfxBeginThread(ThreadProc, &tobj, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
	m_pThread->m_bAutoDelete = FALSE;
	m_pThread->ResumeThread();

	//ワーカスレッドの終了を待ってメインスレッドを終了する
	//WAIT_TIMEOUTとしているので、2000ミリ秒とかの方が良いかも？
	while (WaitForSingleObject(m_pThread->m_hThread, INFINITE) == WAIT_TIMEOUT) {
		// フリーズしないようにする
		MSG msg;
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	//スレッド開放
	delete m_pThread;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	printf("\r\nDone....");
	auto chAnswer = getchar();
	//コンソール開放
	FreeConsole();
	return 0;
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// スレッド関数
UINT ThreadProc(LPVOID param)
{
	//渡されたハンドラを元データにする
	auto closePrice = (*((lpVOID*)param)).closePrice;

	//演算
	double sum = 0.0f;
	for (auto itr = closePrice.begin(); itr != closePrice.end(); itr++)
	{
		sum += (*itr);
	}
	std::cout << "sum : " << sum << "  average : " << sum / closePrice.size() << std::endl;

	//スレッド終了
	return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
